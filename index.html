<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Tasks</title>
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --paper-cream: #faf8f3;
            --paper-line: #d4c5b9;
            --margin-line: #e8b4b8;
            --text-primary: #2c2c2c;
            --text-secondary: #6b6b6b;
            --text-light: #9b9b9b;
            --accent: #5b8ec4;
            --star: #ffc107;
            --green: #4caf50;
            --red: #ef5350;
            --yellow: #ffb74d;
            --shadow: rgba(0, 0, 0, 0.1);
            --line-height: 32px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'DM Sans', -apple-system, sans-serif;
            background: #e8e5de;
            color: var(--text-primary);
            line-height: var(--line-height);
            overflow-x: hidden;
            min-height: 100vh;
            padding: 20px;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            background: var(--paper-cream);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-height: calc(100vh - 40px);
            position: relative;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        /* Top toolbar */
        .toolbar {
            position: sticky;
            top: 0;
            background: rgba(250, 248, 243, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--paper-line);
            padding: 12px 20px;
            display: flex;
            gap: 16px;
            align-items: center;
            z-index: 100;
            flex-wrap: wrap;
            touch-action: manipulation;
        }

        .toolbar-section {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--paper-line);
        }

        /* Paper content area */
        .paper-content {
            flex: 1;
            position: relative;
            padding: 40px 40px 40px 80px;
            min-height: 500px;
        }

        /* Lined paper effect */
        .paper-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(
                transparent,
                transparent calc(var(--line-height) - 1px),
                var(--paper-line) calc(var(--line-height) - 1px),
                var(--paper-line) var(--line-height)
            );
            pointer-events: none;
            z-index: 0;
        }

        /* Left margin line */
        .paper-content::after {
            content: '';
            position: absolute;
            left: 60px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--margin-line);
            pointer-events: none;
            z-index: 1;
        }

        .paper-content > * {
            position: relative;
            z-index: 2;
        }

        .toolbar-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .filter-btn {
            padding: 5px 10px;
            background: white;
            border: 1px solid var(--paper-line);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 1px 2px var(--shadow);
            touch-action: manipulation;
        }

        .filter-btn:active {
            transform: scale(0.95);
        }

        .filter-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .filter-btn .marker-icon {
            font-size: 12px;
        }

        .filter-btn .marker-icon.green,
        .filter-btn .marker-icon.red,
        .filter-btn .marker-icon.yellow {
            width: 10px;
            height: 10px;
        }

        .marker-icon.star { color: var(--star); }
        .marker-icon.green {
            width: 14px;
            height: 14px;
            background: var(--green);
            border-radius: 50%;
            display: inline-block;
        }
        .marker-icon.red {
            width: 14px;
            height: 14px;
            background: var(--red);
            border-radius: 3px;
            display: inline-block;
        }
        .marker-icon.yellow {
            width: 14px;
            height: 14px;
            background: var(--yellow);
            border-radius: 3px;
            display: inline-block;
        }

        /* Canvas layer for drawing */
        #drawingCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 50;
            /* Let pen through but block finger for drawing */
        }

        /* Floating toolbar for confirming drawings */
        .drawing-toolbar {
            position: absolute;
            display: none;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            padding: 8px;
            gap: 6px;
            z-index: 200;
            flex-direction: row;
            align-items: center;
            touch-action: manipulation;
        }

        .drawing-toolbar.visible {
            display: flex;
            animation: popIn 0.2s ease;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .drawing-toolbar-btn {
            width: 40px;
            height: 40px;
            border: 2px solid transparent;
            background: #f5f5f5;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.15s ease;
            touch-action: manipulation;
        }

        .drawing-toolbar-btn:active {
            transform: scale(0.9);
        }

        .drawing-toolbar-btn.marker-option {
            width: 36px;
            height: 36px;
        }

        .drawing-toolbar-btn.marker-option.selected {
            border-color: var(--accent);
            background: rgba(91, 142, 196, 0.1);
        }

        .drawing-toolbar-btn.confirm {
            background: var(--green);
            color: white;
        }

        .drawing-toolbar-btn.cancel {
            background: var(--red);
            color: white;
        }

        .drawing-toolbar-divider {
            width: 1px;
            height: 30px;
            background: #ddd;
            margin: 0 4px;
        }

        /* Task cards (locked handwritten tasks) */
        .task-card {
            position: absolute;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: grab;
            transition: box-shadow 0.2s, border-color 0.2s;
            background: rgba(255, 255, 255, 0.3);
            z-index: 60;
        }

        .task-card:hover {
            border-color: rgba(91, 142, 196, 0.3);
        }

        .task-card.selected {
            border-color: var(--accent);
            box-shadow: 0 2px 12px rgba(91, 142, 196, 0.3);
        }

        .task-card.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .task-card.completed {
            opacity: 0.5;
        }

        /* Task card marker indicator */
        .task-card-marker {
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        /* Task card actions (shown when selected) */
        .task-card-actions {
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        .task-card.selected .task-card-actions {
            display: flex;
        }

        .task-card-action {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            transition: transform 0.15s;
            touch-action: manipulation;
        }

        .task-card-action:active {
            transform: scale(0.9);
        }

        .task-card-action.complete {
            background: var(--green);
            color: white;
        }

        .task-card-action.delete {
            background: var(--red);
            color: white;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.5);
            padding: 3px;
            border-radius: 6px;
            border: 1px solid var(--paper-line);
        }

        .tab {
            padding: 5px 12px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.02em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'DM Sans', sans-serif;
            touch-action: manipulation;
        }

        .tab.active {
            background: var(--accent);
            color: white;
            box-shadow: 0 1px 2px var(--shadow);
        }

        /* Hint text */
        .hint-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-light);
            font-size: 16px;
            text-align: center;
            pointer-events: none;
            opacity: 0.7;
        }

        .hint-text.hidden {
            display: none;
        }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .status-indicator.visible {
            opacity: 1;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .app-container {
                min-height: calc(100vh - 20px);
            }

            .paper-content {
                padding: 30px 20px 30px 50px;
            }

            .paper-content::after {
                left: 40px;
            }

            .toolbar {
                padding: 10px;
                gap: 8px;
            }

            .toolbar-label {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Top Toolbar -->
        <div class="toolbar" id="mainToolbar">
            <!-- Tabs -->
            <div class="toolbar-section tabs">
                <button class="tab active" onclick="switchTab('active')">Active</button>
                <button class="tab" onclick="switchTab('completed')">Done</button>
            </div>

            <div class="toolbar-divider"></div>

            <!-- Filters -->
            <div class="toolbar-section">
                <span class="toolbar-label">Filter:</span>
                <button class="filter-btn active" data-filter="all" onclick="setFilter('all')">All</button>
                <button class="filter-btn" data-filter="star" onclick="setFilter('star')">
                    <span class="marker-icon star">‚òÖ</span>
                </button>
                <button class="filter-btn" data-filter="green" onclick="setFilter('green')">
                    <span class="marker-icon green"></span>
                </button>
                <button class="filter-btn" data-filter="red" onclick="setFilter('red')">
                    <span class="marker-icon red"></span>
                </button>
                <button class="filter-btn" data-filter="yellow" onclick="setFilter('yellow')">
                    <span class="marker-icon yellow"></span>
                </button>
            </div>

            <div class="toolbar-divider"></div>

            <!-- Backup -->
            <div class="toolbar-section">
                <button class="filter-btn" onclick="exportTasks()" title="Export">‚Üì</button>
                <button class="filter-btn" onclick="document.getElementById('importFile').click()" title="Import">‚Üë</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importTasks(event)">
                <button class="filter-btn" onclick="clearAllTasks()" title="Clear All">üóëÔ∏è</button>
            </div>
        </div>

        <!-- Paper Content Area -->
        <div class="paper-content" id="paperContent">
            <!-- Canvas for handwriting -->
            <canvas id="drawingCanvas"></canvas>

            <!-- Hint text -->
            <div class="hint-text" id="hintText">
                Write with Apple Pencil, then tap to save<br>
                <small>Or tap anywhere with finger to type</small>
            </div>

            <!-- Task cards container -->
            <div id="taskCardsContainer"></div>
        </div>

        <!-- Floating drawing toolbar -->
        <div class="drawing-toolbar" id="drawingToolbar">
            <button class="drawing-toolbar-btn marker-option selected" data-marker="none" onclick="selectDrawingMarker('none')" title="No marker">
                ‚Äî
            </button>
            <button class="drawing-toolbar-btn marker-option" data-marker="star" onclick="selectDrawingMarker('star')" title="Star">
                <span class="marker-icon star">‚òÖ</span>
            </button>
            <button class="drawing-toolbar-btn marker-option" data-marker="green" onclick="selectDrawingMarker('green')" title="Green">
                <span class="marker-icon green"></span>
            </button>
            <button class="drawing-toolbar-btn marker-option" data-marker="red" onclick="selectDrawingMarker('red')" title="Red">
                <span class="marker-icon red"></span>
            </button>
            <button class="drawing-toolbar-btn marker-option" data-marker="yellow" onclick="selectDrawingMarker('yellow')" title="Yellow">
                <span class="marker-icon yellow"></span>
            </button>
            <div class="drawing-toolbar-divider"></div>
            <button class="drawing-toolbar-btn confirm" onclick="confirmDrawing()" title="Save task">‚úì</button>
            <button class="drawing-toolbar-btn cancel" onclick="cancelDrawing()" title="Cancel">‚úï</button>
        </div>
    </div>

    <!-- Status indicator -->
    <div class="status-indicator" id="statusIndicator"></div>

    <script>
        // ==================== STATE ====================
        let tasks = [];
        let currentFilter = 'all';
        let currentTab = 'active';
        let selectedDrawingMarker = 'none';
        
        // Drawing state
        let canvas, ctx;
        let isDrawing = false;
        let currentStrokes = [];
        let drawingBounds = null;
        let isPenActive = false;
        
        // Task selection state
        let selectedTaskId = null;
        let isDraggingTask = false;
        let dragOffset = { x: 0, y: 0 };

        // ==================== INITIALIZATION ====================
        function init() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            
            loadTasks();
            resizeCanvas();
            setupEventListeners();
            renderTaskCards();
            updateHintVisibility();
            
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const paperContent = document.getElementById('paperContent');
            const rect = paperContent.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            ctx.scale(dpr, dpr);
            
            redrawCanvas();
        }

        function setupEventListeners() {
            // Canvas events - only respond to pen
            canvas.addEventListener('pointerdown', handlePointerDown, { passive: false });
            canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
            canvas.addEventListener('pointerup', handlePointerUp, { passive: false });
            canvas.addEventListener('pointerleave', handlePointerUp, { passive: false });
            canvas.addEventListener('pointercancel', handlePointerUp, { passive: false });
            
            // Prevent default touch behaviors on canvas
            canvas.addEventListener('touchstart', e => {
                if (isPenActive || isDrawing) e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', e => {
                if (isPenActive || isDrawing) e.preventDefault();
            }, { passive: false });
            
            // Paper content click for typing (finger only)
            document.getElementById('paperContent').addEventListener('click', handlePaperClick);
            
            // Click outside to deselect tasks
            document.addEventListener('click', handleDocumentClick);
            
            // Prevent context menu during drawing
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        // ==================== POINTER HANDLING ====================
        function handlePointerDown(e) {
            // Check if clicking on action buttons or toolbar - let those handle themselves
            const elementAtPoint = document.elementFromPoint(e.clientX, e.clientY);
            if (elementAtPoint && (
                elementAtPoint.closest('.task-card-action') ||
                elementAtPoint.closest('.drawing-toolbar'))) {
                return; // Don't interfere with button clicks
            }

            const point = getCanvasPoint(e);

            // Check if clicking on a task card first
            const clickedTask = findTaskAtPoint(point.x, point.y);

            if (e.pointerType === 'pen') {
                // Pen input - start or continue drawing
                isPenActive = true;

                if (clickedTask && clickedTask.id === selectedTaskId) {
                    // Drag selected task
                    startDraggingTask(clickedTask, point);
                } else {
                    // Start or continue drawing - hide toolbar if it was showing
                    hideDrawingToolbar();
                    deselectTask();
                    startDrawing(point);
                }

                e.preventDefault();
            } else if (e.pointerType === 'touch' || e.pointerType === 'mouse') {
                // Finger/mouse - interact with tasks
                if (clickedTask) {
                    e.preventDefault();
                    if (selectedTaskId === clickedTask.id) {
                        startDraggingTask(clickedTask, point);
                    } else {
                        selectTask(clickedTask.id);
                    }
                }
            }
        }

        function handlePointerMove(e) {
            const point = getCanvasPoint(e);
            
            if (isDraggingTask) {
                e.preventDefault();
                moveTask(point);
                return;
            }
            
            if (isDrawing && e.pointerType === 'pen') {
                e.preventDefault();
                continueDrawing(point);
            }
        }

        function handlePointerUp(e) {
            if (isDraggingTask) {
                stopDraggingTask();
                return;
            }
            
            if (isDrawing) {
                stopDrawing();
            }
            
            isPenActive = false;
        }

        function handlePaperClick(e) {
            // Don't trigger if clicking on task cards, their actions, or toolbars
            if (e.target.closest('.task-card') ||
                e.target.closest('.task-card-action') ||
                e.target.closest('.task-card-actions') ||
                e.target.closest('.drawing-toolbar') ||
                e.target.closest('#mainToolbar')) {
                return;
            }

            // If there's an active drawing, show the toolbar to finalize it
            if (currentStrokes.length > 0 && hasValidStrokes()) {
                drawingBounds = calculateBounds(currentStrokes);
                showDrawingToolbar();
                return;
            }

            // Show prompt for typed task
            const text = prompt('Enter task:');
            if (text && text.trim()) {
                addTypedTask(text.trim(), getCanvasPoint(e));
            }
        }

        function handleDocumentClick(e) {
            // Deselect task if clicking outside
            if (!e.target.closest('.task-card') && 
                !e.target.closest('.task-card-actions') &&
                !e.target.closest('.drawing-toolbar')) {
                if (selectedTaskId && !isDraggingTask) {
                    deselectTask();
                }
            }
        }

        // ==================== DRAWING ====================
        function getCanvasPoint(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function startDrawing(point) {
            isDrawing = true;
            currentStrokes.push({
                points: [point],
                color: '#2c2c2c',
                width: 2
            });
            updateHintVisibility();
        }

        function continueDrawing(point) {
            if (!isDrawing || currentStrokes.length === 0) return;
            
            const stroke = currentStrokes[currentStrokes.length - 1];
            stroke.points.push(point);
            
            // Draw incrementally
            const points = stroke.points;
            if (points.length > 1) {
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(points[points.length - 2].x, points[points.length - 2].y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            }
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;

            // Just stop drawing - don't show toolbar automatically
            // User will tap with finger to bring up toolbar when ready
        }

        function hasValidStrokes() {
            // Check if there's meaningful content
            let totalPoints = 0;
            currentStrokes.forEach(s => totalPoints += s.points.length);
            return totalPoints > 5; // At least a few points
        }

        function calculateBounds(strokes) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            strokes.forEach(stroke => {
                stroke.points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                });
            });
            
            const padding = 10;
            return {
                x: minX - padding,
                y: minY - padding,
                width: maxX - minX + padding * 2,
                height: maxY - minY + padding * 2
            };
        }

        function redrawCanvas() {
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            
            // Draw active task strokes
            tasks.forEach(task => {
                if (!task.strokes) return;
                if (currentTab === 'active' && task.completed) return;
                if (currentTab === 'completed' && !task.completed) return;
                if (currentFilter !== 'all' && task.marker !== currentFilter) return;
                
                drawTaskStrokes(task);
            });
            
            // Draw current drawing
            currentStrokes.forEach(stroke => {
                drawStroke(stroke, 0, 0);
            });
        }

        function drawTaskStrokes(task) {
            const offsetX = (task.position?.x || task.bounds.x) - task.bounds.x;
            const offsetY = (task.position?.y || task.bounds.y) - task.bounds.y;
            
            task.strokes.forEach(stroke => {
                const color = task.completed ? '#999' : stroke.color;
                drawStroke(stroke, offsetX, offsetY, color);
            });
        }

        function drawStroke(stroke, offsetX = 0, offsetY = 0, colorOverride = null) {
            if (stroke.points.length < 2) return;
            
            ctx.strokeStyle = colorOverride || stroke.color;
            ctx.lineWidth = stroke.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(stroke.points[0].x + offsetX, stroke.points[0].y + offsetY);
            for (let i = 1; i < stroke.points.length; i++) {
                ctx.lineTo(stroke.points[i].x + offsetX, stroke.points[i].y + offsetY);
            }
            ctx.stroke();
        }

        // ==================== DRAWING TOOLBAR ====================
        function showDrawingToolbar() {
            const toolbar = document.getElementById('drawingToolbar');
            const paperContent = document.getElementById('paperContent');
            const paperRect = paperContent.getBoundingClientRect();
            
            // Position below the drawing
            let x = drawingBounds.x + drawingBounds.width / 2;
            let y = drawingBounds.y + drawingBounds.height + 15;
            
            // Keep within bounds
            const toolbarWidth = 320;
            x = Math.max(toolbarWidth / 2, Math.min(x, paperRect.width - toolbarWidth / 2));
            y = Math.min(y, paperRect.height - 60);
            
            toolbar.style.left = (paperRect.left + x - toolbarWidth / 2) + 'px';
            toolbar.style.top = (paperRect.top + y) + 'px';
            toolbar.classList.add('visible');
            
            // Reset marker selection
            selectDrawingMarker('none');
        }

        function hideDrawingToolbar() {
            document.getElementById('drawingToolbar').classList.remove('visible');
        }

        function selectDrawingMarker(marker) {
            selectedDrawingMarker = marker;
            document.querySelectorAll('.drawing-toolbar .marker-option').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.marker === marker);
            });
        }

        function confirmDrawing() {
            if (currentStrokes.length === 0) return;
            
            const task = {
                id: Date.now(),
                strokes: currentStrokes,
                bounds: { ...drawingBounds },
                position: { x: drawingBounds.x, y: drawingBounds.y },
                marker: selectedDrawingMarker === 'none' ? null : selectedDrawingMarker,
                completed: false,
                isHandwritten: true
            };
            
            tasks.push(task);
            saveTasks();
            
            currentStrokes = [];
            drawingBounds = null;
            hideDrawingToolbar();
            
            renderTaskCards();
            redrawCanvas();
            updateHintVisibility();
            showStatus('Task saved!');
        }

        function cancelDrawing() {
            currentStrokes = [];
            drawingBounds = null;
            hideDrawingToolbar();
            redrawCanvas();
            updateHintVisibility();
        }

        // ==================== TASK MANAGEMENT ====================
        function addTypedTask(text, position) {
            const task = {
                id: Date.now(),
                text: text,
                position: position || { x: 100, y: 100 },
                marker: null,
                completed: false,
                isHandwritten: false
            };
            
            tasks.push(task);
            saveTasks();
            renderTaskCards();
            updateHintVisibility();
            showStatus('Task added!');
        }

        function findTaskAtPoint(x, y) {
            const activeTasks = tasks.filter(t => {
                if (currentTab === 'active' && t.completed) return false;
                if (currentTab === 'completed' && !t.completed) return false;
                if (currentFilter !== 'all' && t.marker !== currentFilter) return false;
                return true;
            });
            
            // Check in reverse order (top-most first)
            for (let i = activeTasks.length - 1; i >= 0; i--) {
                const task = activeTasks[i];
                const pos = task.position || task.bounds;
                const bounds = task.bounds || { width: 150, height: 40 };
                
                if (x >= pos.x && x <= pos.x + bounds.width &&
                    y >= pos.y && y <= pos.y + bounds.height) {
                    return task;
                }
            }
            return null;
        }

        function selectTask(taskId) {
            selectedTaskId = taskId;
            renderTaskCards();
        }

        function deselectTask() {
            selectedTaskId = null;
            renderTaskCards();
        }

        function startDraggingTask(task, point) {
            isDraggingTask = true;
            selectedTaskId = task.id;
            const pos = task.position || task.bounds;
            dragOffset = {
                x: point.x - pos.x,
                y: point.y - pos.y
            };
            document.body.style.cursor = 'grabbing';
        }

        function moveTask(point) {
            const task = tasks.find(t => t.id === selectedTaskId);
            if (!task) return;
            
            task.position = {
                x: point.x - dragOffset.x,
                y: point.y - dragOffset.y
            };
            
            redrawCanvas();
            renderTaskCards();
        }

        function stopDraggingTask() {
            isDraggingTask = false;
            document.body.style.cursor = '';
            saveTasks();
        }

        function completeTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.completed = true;
                saveTasks();
                deselectTask();
                redrawCanvas();
                renderTaskCards();
                showStatus('Task completed! ‚úì');
            }
        }

        function deleteTask(taskId) {
            tasks = tasks.filter(t => t.id !== taskId);
            saveTasks();
            deselectTask();
            redrawCanvas();
            renderTaskCards();
            updateHintVisibility();
            showStatus('Task deleted');
        }

        // ==================== RENDERING ====================
        function renderTaskCards() {
            const container = document.getElementById('taskCardsContainer');
            container.innerHTML = '';
            
            const filteredTasks = tasks.filter(t => {
                if (currentTab === 'active' && t.completed) return false;
                if (currentTab === 'completed' && !t.completed) return false;
                if (currentFilter !== 'all' && t.marker !== currentFilter) return false;
                return true;
            });
            
            filteredTasks.forEach(task => {
                const card = createTaskCard(task);
                container.appendChild(card);
            });
        }

        function createTaskCard(task) {
            const card = document.createElement('div');
            card.className = 'task-card';
            card.dataset.id = task.id;
            
            if (task.completed) card.classList.add('completed');
            if (task.id === selectedTaskId) card.classList.add('selected');
            
            const pos = task.position || task.bounds || { x: 100, y: 100 };
            const bounds = task.bounds || { width: 150, height: 40 };
            
            card.style.left = pos.x + 'px';
            card.style.top = pos.y + 'px';
            card.style.width = bounds.width + 'px';
            card.style.height = bounds.height + 'px';
            
            // Marker indicator
            if (task.marker) {
                const marker = document.createElement('div');
                marker.className = 'task-card-marker';
                if (task.marker === 'star') {
                    marker.innerHTML = '<span style="color: var(--star);">‚òÖ</span>';
                } else {
                    marker.style.background = `var(--${task.marker})`;
                }
                card.appendChild(marker);
            }
            
            // Actions (visible when selected)
            const actions = document.createElement('div');
            actions.className = 'task-card-actions';

            if (!task.completed) {
                const completeBtn = document.createElement('button');
                completeBtn.className = 'task-card-action complete';
                completeBtn.title = 'Complete';
                completeBtn.textContent = '‚úì';
                completeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    completeTask(task.id);
                });
                actions.appendChild(completeBtn);
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'task-card-action delete';
            deleteBtn.title = 'Delete';
            deleteBtn.textContent = '‚úï';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteTask(task.id);
            });
            actions.appendChild(deleteBtn);

            card.appendChild(actions);
            
            // Click to select
            card.addEventListener('click', (e) => {
                if (!e.target.closest('.task-card-action')) {
                    selectTask(task.id);
                }
            });
            
            return card;
        }

        function updateHintVisibility() {
            const hint = document.getElementById('hintText');
            const activeTasks = tasks.filter(t => !t.completed);
            const hasDrawing = currentStrokes.length > 0;
            
            if (activeTasks.length === 0 && !hasDrawing && currentTab === 'active') {
                hint.classList.remove('hidden');
            } else {
                hint.classList.add('hidden');
            }
        }

        // ==================== UI CONTROLS ====================
        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.toggle('active', t.textContent.toLowerCase().includes(tab));
            });
            deselectTask();
            redrawCanvas();
            renderTaskCards();
            updateHintVisibility();
        }

        function setFilter(filter) {
            currentFilter = filter;
            document.querySelectorAll('.filter-btn[data-filter]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            deselectTask();
            redrawCanvas();
            renderTaskCards();
        }

        function showStatus(message) {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = message;
            indicator.classList.add('visible');
            setTimeout(() => indicator.classList.remove('visible'), 2000);
        }

        // ==================== PERSISTENCE ====================
        function saveTasks() {
            localStorage.setItem('noteTasks', JSON.stringify(tasks));
        }

        function loadTasks() {
            tasks = JSON.parse(localStorage.getItem('noteTasks')) || [];
        }

        function exportTasks() {
            const data = JSON.stringify(tasks, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `tasks-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showStatus('Tasks exported!');
        }

        function importTasks(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (Array.isArray(imported)) {
                        const merge = confirm(`Import ${imported.length} tasks?\n\nOK = Replace all\nCancel = Merge`);
                        if (merge) {
                            tasks = imported;
                        } else {
                            const maxId = Math.max(0, ...tasks.map(t => t.id));
                            imported.forEach((t, i) => t.id = maxId + i + 1);
                            tasks = [...tasks, ...imported];
                        }
                        saveTasks();
                        redrawCanvas();
                        renderTaskCards();
                        updateHintVisibility();
                        showStatus(`Imported ${imported.length} tasks!`);
                    }
                } catch (err) {
                    alert('Error reading file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearAllTasks() {
            if (confirm('Delete ALL tasks? This cannot be undone.')) {
                tasks = [];
                saveTasks();
                redrawCanvas();
                renderTaskCards();
                updateHintVisibility();
                showStatus('All tasks cleared');
            }
        }

        // ==================== SERVICE WORKER ====================
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js');
        }

        // ==================== START ====================
        init();
    </script>
</body>
</html>